"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PaginatorStateManager = void 0;
class PaginatorStateManager {
    constructor(params) {
        const state = PaginatorStateManager.calculateState({
            page: Math.floor(params.page) || 1,
            totalItems: Math.floor(params.totalItems) || 1,
            perPage: Math.floor(params.perPage),
        });
        this.page = state.page;
        this.perPage = state.perPage;
        this.totalItems = state.totalItems;
        this.totalPages = state.totalPages;
        this.offset = state.offset;
    }
    static calculateState(params) {
        const { page, totalItems, perPage } = params;
        const totalPages = Math.ceil(totalItems / perPage);
        const calculatedPage = PaginatorStateManager.calculatePage(page, totalPages);
        const offset = (calculatedPage - 1) * perPage;
        return {
            totalItems,
            perPage,
            totalPages,
            offset,
            page: calculatedPage,
        };
    }
    static calculatePage(page, totalPages) {
        if (page < 1) {
            return totalPages;
        }
        return page > totalPages ? 1 : page;
    }
    getPage() {
        return this.page;
    }
    getTotalPages() {
        return this.totalPages;
    }
    getTotalItems() {
        return this.totalItems;
    }
    getStateByPage(page) {
        return PaginatorStateManager.calculateState({
            page,
            perPage: this.perPage,
            totalItems: this.totalItems,
        });
    }
    getNextPageState() {
        return this.getStateByPage(this.page + 1);
    }
    getPreviousPageState() {
        return this.getStateByPage(this.page - 1);
    }
    extractItems(items) {
        const beginning = this.offset;
        const end = beginning + this.perPage;
        return items.slice(beginning, end);
    }
}
exports.PaginatorStateManager = PaginatorStateManager;
